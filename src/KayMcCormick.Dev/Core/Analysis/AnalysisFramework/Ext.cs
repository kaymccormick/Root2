#region header
// Kay McCormick (mccor)
// 
// WpfApp2
// CodeAnalysisApp1
// Ext.cs
// 
// 2020-02-14-1:05 AM
// 
// ---
#endregion
using System ;
using System.Collections.Generic ;
using System.IO ;
using System.Linq ;
using JetBrains.Annotations ;
using Microsoft.CodeAnalysis ;

namespace AnalysisFramework
{
    /// <summary>Extension class</summary>
    public static class Ext
    {
        // public static implicit operator IEnumerable < ITypeSymbol ? > ( this TypeInfo me )
        //     => new[] { me.Type , me.ConvertedType } ;
        /// <summary>Types the infos.</summary>
        /// <param name="me">Me.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for TypeInfos
        public static IEnumerable < ITypeSymbol > TypeInfos ( this TypeInfo me )
        {
            return new[] { me.Type , me.ConvertedType } ;
        }

        /// <summary>Deconstructs the specified type1.</summary>
        /// <param name="me">Me.</param>
        /// <param name="type1">The type1.</param>
        /// <param name="type2">The type2.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Deconstruct
        // ReSharper disable once UnusedMember.Global
        public static void Deconstruct (
            this TypeInfo    me
          , out  ITypeSymbol  type1
          , out  ITypeSymbol  type2
        )
        {
            type1 = me.Type ;
            type2 = me.ConvertedType ;
        }

        public static string ShortenedPath ( [ NotNull ] this Document doc )
        {
            var strings = doc.FilePath.Split(Path.DirectorySeparatorChar);
            var numElems = 4 ;
            var p = strings.ToList()
                           .GetRange(
                                     strings.Length < numElems  ? 0 : strings.Length - numElems
                                   , strings.Length >= numElems ? 3 : strings.Length
                                    );
            return String.Join(Path.DirectorySeparatorChar.ToString(), p);
        }

        public static string RelativePath ( [ NotNull ] this Document doc )
        {
            return GetRelativePath ( doc.Project.FilePath , doc.FilePath ) ;
        }

        public static string GetRelativePath(string relativeTo, string path)
        {
            var uri = new Uri(relativeTo);
            var rel = Uri
                     .UnescapeDataString(uri.MakeRelativeUri(new Uri(path)).ToString())
                     .Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
            if (rel.Contains(Path.DirectorySeparatorChar.ToString()) == false)
            {
                rel = $".{Path.DirectorySeparatorChar}{rel}";
            }

            return rel;
        }
    }
}