using System;
using System.Collections.Generic;
using System.Reflection;
using System.Windows;
using KayMcCormick.Dev.TestLib.Fixtures ;
using NLog;
using NLog.Layouts;
using Tests.Lib;
using WpfApp;
using WpfApp.Application;
using Xunit;
using Xunit.Abstractions;

namespace Tests.Main
{
    /// <summary>Tests for primary application class <see cref="App"/>.</summary>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for AppTests
    [Collection("GeneralPurpose")]
    public sealed class TestProps : IClassFixture<LoggingFixture>, IDisposable
    {
        // ReSharper disable once InconsistentNaming
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger();
        private readonly LoggingFixture _loggingFixture;

        /// <summary>Initializes a new instance of the <see cref="System.Object" /> class.</summary>
        public TestProps(ITestOutputHelper output, LoggingFixture loggingFixture)
        {
            _loggingFixture = loggingFixture;
            if ( loggingFixture != null )
            {
                loggingFixture.SetOutputHelper ( output , LogLevel.Info ) ;
            }

            _loggingFixture.Layout = Layout.FromString("${message}");
            CheckedMembers = new Dictionary<string, bool>();
        }

        private Dictionary<string, bool> CheckedMembers { get; }

        /// <summary>Tests the props configured.</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for TestPropsConfigured
        // [WpfFact]
        public void TestPropsConfigured()
        {
            try
            {
                TypeToConsider = typeof(Props);
                var props = new List<PropInfo>();
                foreach (var fieldInfo in TypeToConsider.GetFields())
                {
                    if (!fieldInfo.IsStatic)
                    {
                        Logger.Error(
                                      "Discovered non-static field {fieldName} on {type}"
                                    , fieldInfo.Name
                                    , fieldInfo.DeclaringType
                                     );
                        continue;
                    }

                    var endsWithProperty = fieldInfo.Name.EndsWith("Property");
                    var isDependencyPropertyType =
                        typeof(DependencyProperty).IsAssignableFrom(fieldInfo.FieldType);
                    if (endsWithProperty ^ isDependencyPropertyType)
                    {
                        throw new UnexpectedPropertyException(
#pragma warning disable CA1303 // Do not pass literals as localized parameters
                                                               "Properties ending in -Property should be of type DependencyProperty"
#pragma warning restore CA1303 // Do not pass literals as localized parameters
                                                             , fieldInfo
                                                              );
                    }

                    if (!endsWithProperty)
                    {
                        continue;
                    }

                    var value = fieldInfo.GetValue(null);
                    if (value == null)
                    {
#pragma warning disable CA1303 // Do not pass literals as localized parameters
                        throw new UnexpectedPropertyException("Field returns null", fieldInfo);
#pragma warning restore CA1303 // Do not pass literals as localized parameters
                    }

                    if (!(value is DependencyProperty prop))
                    {
                        throw new UnexpectedPropertyException(
#pragma warning disable CA1303 // Do not pass literals as localized parameters
                                                               "Field does not return value that can cast to DependencyProperty"
#pragma warning restore CA1303 // Do not pass literals as localized parameters
                                                             , fieldInfo
                                                              );
                    }

                    CheckDependencyProperty(prop, fieldInfo, props, value);
                    CheckedMembers[fieldInfo.Name] = true;
                }

                foreach (var fieldInfo in TypeToConsider.GetFields())
                {
                    if (CheckedMembers.ContainsKey(fieldInfo.Name))
                    {
#pragma warning disable CA1303 // Do not pass literals as localized parameters
                        Logger.Debug("Checked field {name}, skipping.", fieldInfo.Name);
#pragma warning restore CA1303 // Do not pass literals as localized parameters
                        continue;
                    }

                    var value = fieldInfo.GetValue(null);
                    if (typeof(RoutedEvent).IsAssignableFrom(fieldInfo.FieldType))
                    {
                        CheckRoutedEvent(fieldInfo, value);
                    }
                    else
                    {
                        throw new UnexpectedPropertyException(
#pragma warning disable CA1303 // Do not pass literals as localized parameters
                                                               "Unexpected property"
#pragma warning restore CA1303 // Do not pass literals as localized parameters
                                                             , fieldInfo
                                                              );
                    }
                }

                foreach (var memberInfo in TypeToConsider.GetMembers())
                {
                    if (!CheckedMembers.ContainsKey(memberInfo.Name))
                    {
                        throw new UnexpectedPropertyException(
                                                               "Unchecked member " + memberInfo.Name
                                                             , memberInfo
                                                              );
                    }
                }
            }
            catch (UnexpectedPropertyException ex)
            {
                Logger.Error(ex, ex.Message);
                Assert.True(ex == null, ex.Message);
            }
        }

        /// <summary>Gets or sets the type to consider.</summary>
        /// <value>The type to consider.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for TypeToConsider
        public Type TypeToConsider { get; set; }

        private void CheckDependencyProperty(
            DependencyProperty prop
          , FieldInfo fieldInfo
          , ICollection < PropInfo > props
          , object value
        )
        {
            var propInfo = new PropInfo { DependencyProperty = prop, FieldInfo = fieldInfo };
            props.Add(propInfo);
#pragma warning disable CA1303 // Do not pass literals as localized parameters
            Logger.Debug("{fieldName} is DependencyProperty", fieldInfo.Name);
#pragma warning restore CA1303 // Do not pass literals as localized parameters
            Assert.IsAssignableFrom<DependencyProperty>(value);
            Assert.EndsWith("Property", fieldInfo.Name);
            var name = fieldInfo.Name.Substring(0, fieldInfo.Name.Length - 8);
            Assert.Equal(name, prop.Name);

            var getterName = "Get" + prop.Name;
            Logger.Debug(
                          "Checing property getter {getterName} for property {propName}"
                        , getterName
                        , prop.Name
                         );

            var methodInfo = TypeToConsider.GetMethod(
                                                       getterName
                                                     , BindingFlags.Public | BindingFlags.Static
                                                      );
            Assert.NotNull(methodInfo);
            CheckedMembers[getterName] = true;

            var setterName = "Set" + prop.Name;
            Logger.Debug(
                          "Checing property setter{getterName} for property {propName}"
                        , setterName
                        , prop.Name
                         );
            var setMethodInfo = TypeToConsider.GetMethod(
                                                          setterName
                                                        , BindingFlags.Public | BindingFlags.Static
                                                         );
            Assert.NotNull(setMethodInfo);
            CheckedMembers[setterName] = true;

        }

        private static void CheckRoutedEvent(FieldInfo fieldInfo, object value)
        {
#pragma warning disable CA1303 // Do not pass literals as localized parameters
            Logger.Info("Checking RoutedEvent {fieldName} ", fieldInfo.Name);
#pragma warning restore CA1303 // Do not pass literals as localized parameters
            var @event = value as RoutedEvent;
            Assert.EndsWith("Event", fieldInfo.Name);
            var name = fieldInfo.Name.Substring(0, fieldInfo.Name.Length - 5);
            if (@event != null)
            {
                Assert.Equal(name, @event.Name);
                var hType = typeof(RoutedPropertyChangedEventHandler<object>);
                if (@event.HandlerType.IsGenericType)
                {
                    Logger.Debug("Handler is generic type.");
                    var def = @event.HandlerType.GetGenericTypeDefinition();
                    if (hType.GetGenericTypeDefinition() == def)
                    {
#pragma warning disable CA1303 // Do not pass literals as localized parameters
                        Logger.Debug("Handler is constructed from {baseType}", def.FullName);
#pragma warning restore CA1303 // Do not pass literals as localized parameters
                    }
                    else
                    {
                        throw new UnexpectedPropertyException(
#pragma warning disable CA1303 // Do not pass literals as localized parameters
                                                               "Unexpected handler type"
#pragma warning restore CA1303 // Do not pass literals as localized parameters
                                                             , fieldInfo
                                                              );
                    }

                    Logger.Debug("Generic type definition is {genericTypeDef}", def);
                }

                Logger.Debug(
                              "Event Routing Strategy is {RoutingStrategy}"
                            , @event.RoutingStrategy
                             );
                Logger.Debug("Handler type is {handlerType}", @event.HandlerType);
            }
        }


        /// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        public void Dispose()
        {
            // _loggingFixture?.Dispose ( ) ;
            _loggingFixture.SetOutputHelper(null);
        }
    }

    internal class PropInfo
    {
        // ReSharper disable once UnusedAutoPropertyAccessor.Global
        public DependencyProperty DependencyProperty { get; set; }

        // ReSharper disable once UnusedAutoPropertyAccessor.Global
        public FieldInfo FieldInfo { get; set; }
    }
}