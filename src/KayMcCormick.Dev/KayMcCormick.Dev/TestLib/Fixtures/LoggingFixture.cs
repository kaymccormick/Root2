using System ;
using System.Diagnostics ;
using System.IO ;
using System.Linq ;
using JetBrains.Annotations ;
using KayMcCormick.Dev.Logging ;
using KayMcCormick.Dev.TestLib.Logging ;
using NLog ;
using NLog.Config ;
using NLog.Layouts ;
using Xunit ;
using Xunit.Abstractions ;
using Xunit.Sdk ;

namespace KayMcCormick.Dev.TestLib.Fixtures
{
    /// <summary>
    ///     Test fixture to provide logging for the individual test case. In
    ///     order to use, the individual test class must be tagged with the
    ///     <seealso cref="IClassFixture{TFixture}" />. Method
    ///     <seealso cref="SetOutputHelper" /> must be invoked with the
    ///     <seealso cref="ITestOutputHelper" /> instance supplied by Xunit through
    ///     the class constructor.
    /// </summary>
    // ReSharper disable once ClassNeverInstantiated.Global
    public class LoggingFixture : IDisposable
    {
        private readonly bool _disableLogging ;

        private XunitTarget _xunitTarget ;

        /// <summary>
        ///     Initializes a new instance of the <see cref="System.Object" />
        ///     class.
        /// </summary>
        public LoggingFixture ( IMessageSink sink )
        {
            if ( Environment.GetEnvironmentVariable ( "DISABLE_TEST_LOGGING" ) != null )
            {
                _disableLogging = true ;
                return ;
            }

            var disabled = _disableLogging ? " Logging disabled." : string.Empty ;
            // sink.OnMessage ( new DiagnosticMessage ( $"Constructing LoggingFixture.{disabled}" ) ) ;
            if ( ! _disableLogging )
            {
                FixtureLogger.LogFixtureCreatedLifecycleEvent ( GetType ( ) ) ;
            }
        }

        /// <summary>Gets or sets the layout used to format log messages.</summary>
        /// <remarks>
        ///     The default value of the layout is:
        ///     <v>${longdate}|${level:uppercase=true}|${logger}|${message:withexception=true}</v>
        /// </remarks>
        /// <docgen category="Layout Options" order="1" />

        [ CanBeNull ] public Layout Layout
        {
            get { return _xunitTarget?.Layout ; }
            set
            {
                if ( _xunitTarget != null )
                {
                    _xunitTarget.Layout = value ;
                }
            }
        }


        /// <summary>
        ///     Performs application-defined tasks associated with freeing,
        ///     releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose ( )
        {
            if ( _xunitTarget != null )
            {
                AppLoggingConfigHelper.RemoveTarget ( _xunitTarget ) ;
                _xunitTarget.Dispose ( ) ;
            }

            if ( ! _disableLogging )
            {
                FixtureLogger.LogFixtureFinalizedLifecycleEvent ( GetType ( ) ) ;
            }
        }

        /// <summary>Sets the output helper.</summary>
        /// <param name="value">The value.</param>
        /// <param name="testClass"></param>
        /// <param name="minLogLevel"></param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetOutputHelper
        public void SetOutputHelper (
            ITestOutputHelper value
          , object            testClass   = null
          , LogLevel          minLogLevel = null
        )
        {
            if ( _disableLogging )
            {
                return ;
            }

            if ( _xunitTarget != null )
            {
                AppLoggingConfigHelper.RemoveTarget ( _xunitTarget ) ;
                _xunitTarget.Dispose ( ) ;
            }

            if ( value == null )
            {
                _xunitTarget = null ;
                return ;
            }

            var type = testClass?.GetType ( ) ;
            var att = type?.GetCustomAttributes ( typeof ( LoggingAttribute ) , true )
                      ?? Array.Empty < Attribute > ( ) ;

            _xunitTarget = new XunitTarget ( "Xunit" ) { OutputHelper = value } ;
            AppLoggingConfigHelper.AddTarget ( _xunitTarget , minLogLevel ) ;


            var fUpdated = false ;
            var context = new LoggingAttributeContext { Target = _xunitTarget } ;
            // ReSharper disable once UnusedVariable
            foreach ( var o in from LoggingAttribute o in att where o.Apply ( context ) select o )
            {
                fUpdated = true ;
            }


            if ( testClass != null )
            {
                var rules = testClass.GetType ( )
                                     .GetCustomAttributes (
                                                           typeof ( LoggingRuleAttribute )
                                                         , true
                                                          ) ;
                foreach ( var rule in rules )
                {
                    if ( ! ( rule is LoggingRuleAttribute la ) )
                    {
                        continue ;
                    }

                    var rule2 = new LoggingRule (
                                                 la.LoggerNamePattern
                                               , la.Level
                                               , _xunitTarget
                                                ) ;
                    AppLoggingConfigHelper.AddRule ( rule2 ) ;
                    fUpdated = true ;
                }
            }

            LogManager.ReconfigExistingLoggers ( ) ;
            if ( ! fUpdated )
            {
                return ;
            }

            LogManager.ReconfigExistingLoggers ( ) ;
            var sw = new StringWriter ( ) ;
            Utils.PerformLogConfigDump ( sw ) ;
            Debug.Write ( sw ) ;
            // value.WriteLine(sw.ToString());
        }
    }
}