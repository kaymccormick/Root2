using System ;
using System.Diagnostics ;
using System.IO ;
using KayMcCormick.Dev.Logging ;
using KayMcCormick.Dev.TestLib.Logging ;
using NLog ;
using NLog.Config ;
using NLog.Layouts ;
using Xunit ;
using Xunit.Abstractions ;
using Xunit.Sdk ;

namespace KayMcCormick.Dev.TestLib.Fixtures
{
    /// <summary>
    ///     Test fixture to provide logging for the individual test case. In
    ///     order to use, the individual test class must be tagged with the
    ///     <seealso cref="IClassFixture{TFixture}" />. Method
    ///     <seealso cref="SetOutputHelper" /> must be invoked with the
    ///     <seealso cref="ITestOutputHelper" /> instance supplied by Xunit through
    ///     the class constructor.
    /// </summary>
    public class LoggingFixture : IDisposable
    {
        private readonly bool _disableLogging ;

        private XunitTarget _xunitTarget ;

        /// <summary>
        ///     Initializes a new instance of the <see cref="System.Object" />
        ///     class.
        /// </summary>
        public LoggingFixture ( IMessageSink sink )
        {
            if ( Environment.GetEnvironmentVariable ( "DISABLE_TEST_LOGGING" ) != null )
            {
                _disableLogging = true ;
                return ;
            }

            var disabled = _disableLogging ? " Logging disabled." : string.Empty ;
            sink.OnMessage ( new DiagnosticMessage ( $"Constructing LoggingFixture.{disabled}" ) ) ;
            if ( ! _disableLogging )
            {
                FixtureLogger.LogFixtureCreatedLifecycleEvent ( GetType ( ) ) ;
            }
        }

        /// <summary>Gets or sets the layout used to format log messages.</summary>
        /// <remarks>
        ///     The default value of the layout is:
        ///     <v>${longdate}|${level:uppercase=true}|${logger}|${message:withexception=true}</v>
        /// </remarks>
        /// <docgen category="Layout Options" order="1" />

        public Layout Layout
        {
            get { return _xunitTarget?.Layout ; }
            set
            {
                if ( _xunitTarget != null )
                {
                    _xunitTarget.Layout = value ;
                }
            }
        }


        /// <summary>
        ///     Performs application-defined tasks associated with freeing,
        ///     releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose ( )
        {
            if ( _xunitTarget != null )
            {
                AppLoggingConfigHelper.RemoveTarget ( _xunitTarget ) ;
                _xunitTarget.Dispose ( ) ;
            }

            if ( ! _disableLogging )
            {
                FixtureLogger.LogFixtureFinalizedLifecycleEvent ( GetType ( ) ) ;
            }
        }

        /// <summary>Sets the output helper.</summary>
        /// <param name="value">The value.</param>
        /// <param name="testClass"></param>
        /// <param name="minLogLevel"></param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetOutputHelper
        public void SetOutputHelper (
            ITestOutputHelper value
          , object            testClass   = null
          , LogLevel          minLogLevel = null
        )
        {
            if ( _disableLogging )
            {
                return ;
            }

            if ( _xunitTarget != null )
            {
                AppLoggingConfigHelper.RemoveTarget ( _xunitTarget ) ;
                _xunitTarget.Dispose ( ) ;
            }

            if ( value == null )
            {
                _xunitTarget = null ;
                return ;
            }

            var type = testClass?.GetType ( ) ;
            var att = type?.GetCustomAttributes ( typeof ( LoggingAttribute ) , true )
                      ?? Array.Empty < Attribute > ( ) ;

            _xunitTarget = new XunitTarget ( "Xunit" ) { OutputHelper = value } ;
            AppLoggingConfigHelper.AddTarget ( _xunitTarget , minLogLevel ) ;


            var fUpdated = false ;
            var context = new LoggingAttributeContext { Target = _xunitTarget } ;
            foreach ( LoggingAttribute o in att )
            {
                if ( o.Apply ( context ) )
                {
                    fUpdated = true ;
                }
            }


            if ( testClass != null )
            {
                var rules = testClass.GetType ( )
                                     .GetCustomAttributes (
                                                           typeof ( LoggingRuleAttribute )
                                                         , true
                                                          ) ;
                foreach ( var rule in rules )
                {
                    if ( rule is LoggingRuleAttribute la )
                    {
                        var rule2 = new LoggingRule (
                                                     la.LoggerNamePattern
                                                   , la.Level
                                                   , _xunitTarget
                                                    ) ;
                        AppLoggingConfigHelper.AddRule ( rule2 ) ;
                        fUpdated = true ;
                    }
                }
            }

            LogManager.ReconfigExistingLoggers ( ) ;
            if ( fUpdated )
            {
                LogManager.ReconfigExistingLoggers ( ) ;
                var sw = new StringWriter ( ) ;
                Utils.PerformLogConfigDump ( sw ) ;
                Debug.Write ( sw ) ;
                // value.WriteLine(sw.ToString());
            }
        }
    }
}