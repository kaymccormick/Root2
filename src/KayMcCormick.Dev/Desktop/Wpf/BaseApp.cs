using System ;
using System.Collections.Generic ;
using System.Configuration ;
using System.Diagnostics ;
using System.Linq ;
using System.Reflection ;
using System.Windows ;
using Autofac ;
using Autofac.Core ;
#if COMMANDLINE
using CommandLine ;
using CommandLine.Text ;
#endif
using KayMcCormick.Dev ;
using KayMcCormick.Dev.Attributes ;
using KayMcCormick.Dev.Logging ;
using NLog ;
using NLog.Targets ;
using Application = System.Windows.Application ;

namespace KayMcCormick.Lib.Wpf
{
#if COMMANDLINE
    public abstract class BaseOptions
    {
        [ Option ( 'q' ) ]
        public bool QuitOnError { get ; set ; }

        [ Option ( 't' ) ]
        public bool EnableTracing { get ; set ; }
    }
#endif
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public abstract class BaseApp : Application, IDisposable
    {
        
        private ILifetimeScope scope ;
        private readonly ApplicationInstance appInst ;
        private EventLog _eventLog ;
#if COMMANDLINE
        private Type[]                  _optionType ;
        private ParserResult < object > _argParseResult ;
#endif
        protected BaseApp ( )
        {
            _eventLog = new EventLog ( "Application" ) ;
            _eventLog.Source = "Application" ;
            var configs = ApplyConfiguration ( ) ;
            appInst = new ApplicationInstance (
                                               message => {
                                                   if ( _eventLog != null )
                                                   {
                                                       _eventLog.WriteEntry (
                                                                             message
                                                                           , EventLogEntryType
                                                                                .Information
                                                                            ) ;
                                                   }
                                               }
                                             , configs
                                              ) ;
            foreach ( var myJsonLayout in LogManager
                                         .Configuration.AllTargets.OfType < TargetWithLayout > ( )
                                         .Select ( t => t.Layout )
                                         .OfType < MyJsonLayout > ( ) )
            {
                var options = myJsonLayout.CreateJsonSerializerOptions ( ) ;
                options.Converters.Add ( new DataTemplateKeyConverter ( ) ) ;
                myJsonLayout.Options = options ;
            }
        }

        /// <summary>Gets a value indicating whether [do tracing].</summary>
        /// <value>
        ///     <see language="true"/> if [do tracing]; otherwise, <see language="false"/>.
        /// </value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DoTracing
        public bool DoTracing { get ; } = false ;

        protected void SetupTracing ( )
        {
            PresentationTraceSources.Refresh ( ) ;
            if ( DoTracing )
            {
                var nLogTraceListener = new NLogTraceListener ( ) ;
                var routedEventSource = PresentationTraceSources.RoutedEventSource ;
                nLogTraceListener.DefaultLogLevel = LogLevel.Debug ;
                nLogTraceListener.ForceLogLevel   = LogLevel.Warn ;
                //nLogTraceListener.LogFactory      = AppContainer.Resolve < LogFactory > ( ) ;
                nLogTraceListener.AutoLoggerName = false ;
                //nLogTraceListener.
                routedEventSource.Switch.Level = SourceLevels.All ;
                var foo = ResolutionExtensions.Resolve < IEnumerable < TraceListener > > ( Scope ) ;
                foreach ( var tl in foo )
                {
                    routedEventSource.Listeners.Add ( tl ) ;
                }

                //routedEventSource.Listeners.Add ( new AppTraceListener ( ) ) ;
                routedEventSource.Listeners.Add ( nLogTraceListener ) ;
            }
        }

        public ILifetimeScope Scope { get => scope ; set => scope = value ; }

        protected LogDelegates.LogMethod DebugLog { get ; set ; }

        /// <summary>Gets the configuration settings.</summary>
        /// <value>The configuration settings.</value>
        public List < object > ConfigSettings { get ; } = new List < object > ( ) ;

        protected ILogger Logger { get ; set ; }

        protected static void ErrorExit ( ExitCode exitCode = ExitCode.GeneralError )
        {
            var code = Convert.ChangeType ( exitCode , exitCode.GetTypeCode ( ) ) ;
            if ( code != null )
            {
                var intCode = ( int ) code ;

                if ( Current == null )
                {
                    Process.GetCurrentProcess ( ).Kill ( ) ;
                }
                else
                {
                    Current.Shutdown ( intCode ) ;
                }
            }
        }

        public virtual IEnumerable < IModule > GetModules ( ) { return Array.Empty < IModule > ( ) ; }
        #region Overrides of Application
        protected override void OnExit ( ExitEventArgs e )
        {
            base.OnExit ( e ) ;
            appInst.Dispose();
            _eventLog?.Dispose();

        }

        protected override void OnStartup ( StartupEventArgs e )
        {
            foreach ( var module in GetModules ( ) )
            {
                Logger?.Debug ( "Adding module {module}" , module .ToString()) ;
                appInst.AddModule(module);
            }
            appInst.Initialize ( ) ;
            appInst.Startup();
            Scope = appInst.GetLifetimeScope ( ) ;
            base.OnStartup ( e ) ;
#if COMMANDLINE
            var optionTypes = OptionTypes ;
            var args = e.Args ;
            if ( e.Args.Length       == 0
                 || e.Args[ 0 ][ 0 ] == '-' )
            {
                args = args.Prepend ( "default" ).ToArray ( ) ;
            }
            ArgParseResult = Parser.Default.ParseArguments ( args , optionTypes ) ;
             ArgParseResult.WithNotParsed ( OnArgumentParseError ) ;
#endif
        }



#if COMMANDLINE
protected abstract void OnArgumentParseError ( IEnumerable < object > obj ) ;

        public ParserResult < object > ArgParseResult
        {
            get => _argParseResult ;
            set => _argParseResult = value ;
        }
        public virtual Type[] OptionTypes => _optionType ;
#endif
        #endregion

        #region IDisposable
        public virtual void Dispose ( )
        {
            appInst?.Dispose ( ) ;
        }
        #endregion

        protected IEnumerable < object > ApplyConfiguration ( )
        {
            var config = ConfigurationManager.OpenExeConfiguration ( ConfigurationUserLevel.None ) ;
            LogDelegates.LogMethod logMethod2 = DebugLog ?? (m => Debug.WriteLine(m));
            logMethod2?.Invoke( config.FilePath ) ;
            var type1 = typeof ( ContainerHelperSection ) ;

            try
            {
                var sections = config.Sections ;
                foreach ( ConfigurationSection configSection in sections )
                {
                    try
                    {
                        var type = configSection.SectionInformation.Type ;
                        // DoLogMethod ( $"Type is {type}" ) ;
                        var sectionType = Type.GetType ( type ) ;
                        if ( sectionType             != null
                             && sectionType.Assembly == type1.Assembly )
                        {
                            logMethod2 ( "Found section " + sectionType.Name ) ;
                            var at = sectionType.GetCustomAttribute < ConfigTargetAttribute > ( ) ;
                            var configTarget = Activator.CreateInstance ( at.TargetType ) ;
                            var infos = sectionType
                                       .GetMembers ( )
                                       .Select (
                                                info => Tuple.Create (
                                                                      info
                                                                    , info
                                                                         .GetCustomAttribute <
                                                                              ConfigurationPropertyAttribute
                                                                          > ( )
                                                                     )
                                               )
                                       .Where ( tuple => tuple.Item2 != null )
                                       .ToArray ( ) ;
                            foreach ( var (item1 , _) in infos )
                            {
                                if ( item1.MemberType == MemberTypes.Property )
                                {
                                    var attr = at.TargetType.GetProperty ( item1.Name ) ;
                                    try
                                    {
                                        var configVal =
                                            ( ( PropertyInfo ) item1 ).GetValue ( configSection ) ;
                                        if ( attr != null )
                                        {
                                            attr.SetValue ( configTarget , configVal ) ;
                                        }
                                    }
                                    catch ( Exception ex )
                                    {
                                        logMethod2?.Invoke (
                                                            $"Unable to set property {attr.Name}: {ex.Message}"
                                                           ) ;
                                    }
                                }
                            }


                            ConfigSettings.Add ( configTarget ) ;
                        }
                    }
                    catch ( Exception ex1 )
                    {
                        Logger.Error ( ex1 , ex1.Message ) ;
                    }
                }
            }
            catch ( Exception ex )
            {
                logMethod2 ( ex.Message ) ;
            }

            return ConfigSettings ;
        }
    }
}
