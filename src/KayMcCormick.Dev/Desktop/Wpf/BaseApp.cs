using System ;
using System.Collections.Generic ;
using System.ComponentModel ;
using System.Diagnostics ;
using System.IO ;
using System.Linq ;
using System.Windows ;
using Autofac ;
using CommandLine ;
using CommandLine.Text ;
using KayMcCormick.Dev ;
using NLog ;
using static KayMcCormick.Dev.Logging.AppLoggingConfigHelper ;

namespace KayMcCormick.Lib.Wpf
{
    public abstract class BaseOptions
    {
        [ Option ( 'q' ) ]
        public bool QuitOnError { get ; set ; }

        [ Option ( 't' ) ]
        public bool EnableTracing { get ; set ; }
    }

    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public abstract class BaseApp : Application
    {
        private IComponentContext       scope ;
        private Type[]                  _optionType ;
        private ParserResult < object > _argParseResult ;

        /// <summary>Initializes a new instance of the <see cref="T:System.Windows.Application" /> class.</summary>
        /// <exception cref="System.InvalidOperationException">More than one instance of the <see cref="System.Windows.Application" /> class is created per <see cref="System.AppDomain" />.</exception>
        public BaseApp ( ) { EnsureLoggingConfigured ( ) ; }

        /// <summary>Gets a value indicating whether [do tracing].</summary>
        /// <value>
        ///     <see language="true"/> if [do tracing]; otherwise, <see language="false"/>.
        /// </value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DoTracing
        public bool DoTracing { get ; } = false ;

        protected void SetupTracing ( )
        {
            PresentationTraceSources.Refresh ( ) ;
            if ( DoTracing )
            {
                var nLogTraceListener = new NLogTraceListener ( ) ;
                var routedEventSource = PresentationTraceSources.RoutedEventSource ;
                nLogTraceListener.DefaultLogLevel = LogLevel.Debug ;
                nLogTraceListener.ForceLogLevel   = LogLevel.Warn ;
                //nLogTraceListener.LogFactory      = AppContainer.Resolve < LogFactory > ( ) ;
                nLogTraceListener.AutoLoggerName = false ;
                //nLogTraceListener.
                routedEventSource.Switch.Level = SourceLevels.All ;
                var foo = ResolutionExtensions.Resolve < IEnumerable < TraceListener > > ( Scope ) ;
                foreach ( var tl in foo )
                {
                    routedEventSource.Listeners.Add ( tl ) ;
                }

                //routedEventSource.Listeners.Add ( new AppTraceListener ( ) ) ;
                routedEventSource.Listeners.Add ( nLogTraceListener ) ;
            }
        }

        public IComponentContext Scope => scope ;

        protected void ErrorExit ( ExitCode exitCode = ExitCode.GeneralError )
        {
            var code = Convert.ChangeType ( exitCode , exitCode.GetTypeCode ( ) ) ;
            if ( code != null )
            {
                var intCode = ( int ) code ;

                if ( Current == null )
                {
                    Process.GetCurrentProcess ( ).Kill ( ) ;
                }
                else
                {
                    Current.Shutdown ( intCode ) ;
                }
            }
        }

        #region Overrides of Application
        protected override void OnStartup ( StartupEventArgs e )
        {
            base.OnStartup ( e ) ;
            var optionTypes = OptionTypes ;
            var args = e.Args ;
            if ( e.Args.Length       == 0
                 || e.Args[ 0 ][ 0 ] == '-' )
            {
                args = args.Prepend ( "default" ).ToArray ( ) ;
            }
            // ArgParseResult = Parser.Default.ParseArguments ( args , optionTypes ) ;
            // ArgParseResult.WithNotParsed ( OnArgumentParseError ) ;
        }

        protected abstract void OnArgumentParseError ( IEnumerable < object> obj ) ;

        public ParserResult < object > ArgParseResult
        {
            get => _argParseResult ;
            set => _argParseResult = value ;
        }

        public virtual Type[] OptionTypes => _optionType ;
        #endregion
    }
}

