using System ;
using System.Collections.Generic ;
using System.Linq ;
using System.Windows.Controls ;
using System.Windows.Navigation ;
using AnalysisFramework ;
using Autofac ;
using KayMcCormick.Dev;
using KayMcCormick.Dev.TestLib.Fixtures ;
using Microsoft.CodeAnalysis ;
using NLog ;
using NLog.Layouts ;
using ProjLib ;
using Xunit ;
using Xunit.Abstractions ;

namespace ProjTests
{
    [Collection("GeneralPurpose")]
    public class ContainerTests : IClassFixture<LoggingFixture>, IDisposable
    {
        // ReSharper disable once UnusedMember.Local
        // ReSharper disable once InconsistentNaming
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger();
        private readonly ITestOutputHelper _output ;
        private readonly LoggingFixture _loggingFixture;

        /// <summary>Initializes a new instance of the <see cref="System.Object" /> class.</summary>
        public ContainerTests(ITestOutputHelper output, LoggingFixture loggingFixture)
        {
            _output = output ;
            _loggingFixture = loggingFixture;
            loggingFixture.SetOutputHelper(output);
            _loggingFixture.Layout = Layout.FromString("${message}");
        }

        /// <summary>Tests application of configuration in the app.config file.</summary>
        /// <autogeneratedoc />d ndfajdsad
        /// TODO Edit XML Comment Template for TestApplyConfiguration

        [WpfFact]
        void TestContanier ( )
        {
            ISyntaxTreeContext c = AnalysisService.Parse ( LibResources.Program_Parse , "x" ) ;

            using ( var appinst = new ApplicationInstance ( _output.WriteLine ) )
            {
                appinst.AddModule ( new ProjLibModule ( ) ) ;
                var x = appinst.GetLifetimeScope ( ) ;
            var s = x.BeginLifetimeScope (
                                          b => {

                                              b.RegisterInstance ( c.SyntaxTree )
                                               .As < SyntaxTree > ( ) ;

                                              b.RegisterInstance ( c )
                                               .As < ICompilationUnitRootContext > ( ) ;
                                          }
                                         ) ;
            var pages = s.Resolve < IEnumerable < Page > > ( ) ;
            var collection = pages.ToList ( ) ;
            Assert.NotEmpty(collection);
            foreach ( var page in collection )
            {
                NavigationWindow w = new NavigationWindow();
                w.Content = page ;
                w.ShowDialog ( ) ;

            }
            var y = x.Resolve < IWorkspacesViewModel > ( ) ;
            Logger.Debug("{viewModel}", y);
            #if VSSETTINGS
            var p = x.Resolve<IMruItemProvider>();
            Assert.NotEmpty(y.VsCollection);
            foreach ( var vsInstance in y.VsCollection )
            {
                
                Logger.Debug(vsInstance.DisplayName);
                // Assert.NotNull(vsInstance.InstallationPath);
                // Assert.NotNull(vsInstance.ProductPath);
                var mruItemListFor = p.GetMruItemListFor ( vsInstance ) ;
                if ( !mruItemListFor.Any ( ) )
                {
                    Logger.Debug ( "no mru" ) ;
                }
                Assert.Equal(vsInstance.MruItems.Count, mruItemListFor.Count);
                foreach ( var mruItem in mruItemListFor )
                {
                    Logger.Debug(mruItem.FilePath);
                }
            }
#endif

}            
        }
        /// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        public void Dispose()
        {
            // _loggingFixture?.Dispose ( ) ;
            _loggingFixture.SetOutputHelper(null);
        }
    }
}
