#region header
// Kay McCormick (mccor)
// 
// KayMcCormick.Dev
// ProjTests
// ProjTests.cs
// 
// 2020-02-21-12:38 AM
// 
// ---
#endregion
using System ;
using System.Collections.Generic ;
using System.Diagnostics ;
using System.IO ;
using System.Linq ;
using System.Runtime.ExceptionServices ;
using System.Threading ;
using System.Threading.Tasks ;
using System.Windows ;
using System.Windows.Controls ;
using System.Windows.Markup ;
using System.Windows.Media ;
using System.Windows.Threading ;
using Autofac ;
using CodeAnalysisApp1 ;
using KayMcCormick.Dev.TestLib.Fixtures ;
using Microsoft.Build.Locator ;
using Microsoft.CodeAnalysis ;
using Microsoft.CodeAnalysis.CSharp ;
using Microsoft.CodeAnalysis.CSharp.Syntax ;
using NLog ;
using NLog.Layouts ;
using ProjInterface ;
using ProjLib ;
using Xunit ;
using Xunit.Abstractions ;
using FormattedCode = ProjLib.FormattedCode ;

namespace ProjTests
{
    /// <summary>Tests for primary application class <see cref="App"/>.</summary>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for AppTests
    [ Collection ( "GeneralPurpose" ) ]
    public class ProjTests : IClassFixture < LoggingFixture >
      , IClassFixture < ProjectFixture >
      , IDisposable
    {
        private string code =
            "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing NLog ;\n\nnamespace LogTest\n{\n    class Program\n    {\n        private static readonly  Logger Logger = LogManager.GetCurrentClassLogger();\n        static void Main(string[] args) {\n            Action<string> xx = Logger.Info;\n            xx(\"hi\");\n            Logger.Debug ( \"Hello\" ) ;\n            try {\n                string xxx = null;\n                var q = xxx.ToString();\n            } catch(Exception ex) {\n                Logger.Info(ex, ex.Message);\n            }\n            var x = Logger;\n            // doprocess\n            x.Info(\"hello {test} {ab}\", 123, 45);\n        }\n\n    }\n}\n" ;

        public SyntaxTree TestSyntaxTree
        {
            get
            {
                if ( _testSyntaxTree == null )
                {
                    _testSyntaxTree = CSharpSyntaxTree.ParseText ( code ) ;
                }

                return _testSyntaxTree ;
            }
        }


        public CSharpCompilation Compilation
        {
            get
            {
                if ( _compilation == null )
                {
                    _compilation = CreateCompilation ( TestSyntaxTree , "TestSyntaxTree" ) ;
                }

                return _compilation ;
            }
        }

        public CSharpCompilation CreateCompilation ( SyntaxTree syntaxTree , string assemblyName )
        {
            var compilation = CSharpCompilation.Create ( assemblyName )
                                               .AddReferences (
                                                               MetadataReference.CreateFromFile (
                                                                                                 typeof
                                                                                                     ( string
                                                                                                     ).Assembly
                                                                                                      .Location
                                                                                                )
                                                             , MetadataReference.CreateFromFile (
                                                                                                 typeof
                                                                                                     ( Logger
                                                                                                     ).Assembly
                                                                                                      .Location
                                                                                                )
                                                              )
                                               .AddSyntaxTrees ( syntaxTree ) ;
            return compilation ;
        }


        // ReSharper disable once UnusedMember.Local
        // ReSharper disable once InconsistentNaming
        private static   Logger            Logger = LogManager.GetCurrentClassLogger ( ) ;
        private readonly LoggingFixture    _loggingFixture ;
        private          SyntaxTree        _testSyntaxTree ;
        private          CSharpCompilation _compilation ;

        /// <summary>Initializes a new instance of the <see cref="System.Object" /> class.</summary>
        public ProjTests (
            ITestOutputHelper output
          , LoggingFixture    loggingFixture
          , ProjectFixture    projectFixture
        )
        {
            _loggingFixture = loggingFixture ;
            VSI             = projectFixture.I ;
            loggingFixture.SetOutputHelper ( output ) ;
            _loggingFixture.Layout = Layout.FromString ( "${message}" ) ;
        }

        public VisualStudioInstance VSI { get ; set ; }

        /// <summary>Tests application of configuration in the app.config file.</summary>
        /// <autogeneratedoc />d ndfajdsad
        /// TODO Edit XML Comment Template for TestApplyConfiguration
#if false
        [Fact]
        public async Task TestProject( )
        {
            Assert.NotNull(VSI);
            var root = @"C:\Users\mccor.LAPTOP-T6T0BN1K\source\repos";
            var p = Path.Combine(root, @"V2\LogTest\LogTest.sln");
            Assert.True(File.Exists(p));
            ProjLib.ProjectHandler v =
                new ProjectHandler(p, VSI);
            await v.LoadAsync ( );
            v.ProcessProject += ( workspace , project ) => {
                Logger.Debug ( "project is {project}" , project.Name ) ;
            } ;
            v.ProcessDocument += document => {
                Logger.Debug (
                              "Document: {doc} {sourcecode}"
                    , document.Name
                    , document.SourceCodeKind
                             ) ;
            } ;
            await v.ProcessAsync ( ) ;

        }
        [ Theory ]
        //[InlineData( @"V2\WpfApp\WpfApp.sln")]
        [ InlineData ( @"V3\copy\src\KayMcCormick.Dev\KayMcCormick.dev.sln" ) ]
        [ InlineData ( @"V2\LogTest\LogTest.sln" ) ]
        public async Task<object> TestProject2 ( string p1 )
        {
            Assert.NotNull ( VSI ) ;
            var root = @"C:\Users\mccor.LAPTOP-T6T0BN1K\source\repos" ;
            var solution = @"V2\WpfApp\WpfApp.sln" ;
            solution = @"V2\LogTest\LogTest.sln" ;
            var p = Path.Combine ( root , p1 ) ;
            Assert.True ( File.Exists ( p ) ) ;
            var projectHandlerImpl = new ProjectHandlerImpl ( p , VSI, SynchronizationContext.Current) ;
            await projectHandlerImpl.LoadAsync ( ) ;
            projectHandlerImpl.ProcessProject += ( workspace , project ) => {
                Logger.Debug ( "project is {project}" , project.Name, Dispatcher.CurrentDispatcher) ;
            } ;
            projectHandlerImpl.ProcessDocument += document => {
                Logger.Trace (
                              "Document: {doc} {sourcecode}"
                            , document.Name
                            , document.SourceCodeKind
                             ) ;
            } ;
            Func<Tuple<SyntaxTree, SemanticModel, CompilationUnitSyntax>,
                WorkspacesViewModel.CreateFormattedCodeDelegate2> d = t
                => new WorkspacesViewModel.CreateFormattedCodeDelegate2(() => new FormattedCode());

            await projectHandlerImpl.ProcessAsync ( invocation => { }, SynchronizationContext.Current, d ) ;
            foreach ( var yy in projectHandlerImpl.OutputList )
            {
                Logger.Info (
                             "{item1} {item2} {item3}"
                           , yy.Item1
                           , yy.Item2
                           , string.Join ( ";" , yy.Item3.Select ( tuple => tuple.Item2 ) )
                            ) ;
            }

            foreach ( var inv in projectHandlerImpl.Invocations )
            {
                Logger.Error (
                              "{path} {line} {msgval} {list}"
                            , inv.SourceLocation
                            , inv.MethodSymbol.Name
                            , inv.Msgval
                             ) ;
            }
        }

        [ WpfTheory ]
        [ InlineData ( @"V2\LogTest\LogTest.sln" , "LogTest" , "Program.cs" ) ]
        public void TestProject3 ( string p1 , string proj , string doc )
        {
            Task.WaitAll ( Command_ ( p1 , proj , doc, Container.GetScope() ) ) ;
        }

        private async Task Command_ (
            string         p1
          , string         proj
          , string         doc
          , ILifetimeScope scope
        )
        {
            Assert.NotNull ( VSI ) ;
            var root = @"C:\Users\mccor.LAPTOP-T6T0BN1K\source\repos" ;
            var p = Path.Combine ( root , p1 ) ;
            Assert.True ( File.Exists ( p ) ) ;
            // getScope.Resolve < ProjectHandlerImpl > ( ) ;
            var projectHandlerImpl = new ProjectHandlerImpl ( p , VSI, SynchronizationContext.Current) ;
            await projectHandlerImpl.LoadAsync ( ) ;
            projectHandlerImpl.ProcessProject += ( workspace , project ) => {
                Logger.Debug ( "project is {project}" , project.Name ) ;
            } ;
            projectHandlerImpl.ProcessDocument += document => {
                Logger.Trace ( "Document: {doc} {sourcecode}" , document.Name , document.SourceCodeKind ) ;
            } ;
            var theDocument = projectHandlerImpl.Workspace.CurrentSolution.Projects
                                                .Single ( project => project.Name             == proj )
                                                .Documents.Single ( document => document.Name == doc ) ;
            await projectHandlerImpl.OnPrepareProcessDocumentAsync ( theDocument ).ConfigureAwait ( true ) ;
            Action < LogInvocation > consumeLogInvocation = invocation => {
                var container = new StackPanel ( ) { Orientation = Orientation.Vertical } ;

                var visitor = scope.Resolve < Visitor2 > ( ) ;
                visitor.Visit ( invocation.Statement ) ;
            } ;
            await projectHandlerImpl.OnProcessDocumentAsync ( theDocument , consumeLogInvocation )
                                    .ConfigureAwait ( true ) ;
            foreach ( var yy in projectHandlerImpl.OutputList )
            {
                Logger.Info (
                             "{item1} {item2} {item3}"
                           , yy.Item1
                           , yy.Item2
                           , string.Join ( ";" , yy.Item3.Select ( tuple => tuple.Item2 ) )
                            ) ;
            }
        }

        [ WpfFact ]
        public void TestSyyles ( )
        {
            var x = new ResourceDictionary ( ) ;
            foreach ( var xx in Enum.GetValues ( typeof ( SyntaxKind ) ) )
            {
                var s = new Style ( ) ;
                s.Setters.Add ( new Setter ( Control.ForegroundProperty , Brushes.Black ) ) ;
                Logger.Info ( "{x}" , s ) ;
                x.Add ( xx.ToString ( ) , s ) ;
            }

            Logger.Info ( "{}" , XamlWriter.Save ( x ) ) ;
        }

        [ WpfFact ]
        public void TestStyles2 ( )
        {
            var x = new ResourceDictionary ( ) ;
            foreach ( var xx in Enum.GetValues ( typeof ( SyntaxKind ) ) )
            {
                var s = new Style ( ) ;
                s.Setters.Add ( new Setter ( Control.ForegroundProperty , Brushes.Black ) ) ;
                s.Setters.Add ( new Setter ( Control.BackgroundProperty , Brushes.White ) ) ;
                Logger.Info ( "{x}" , s ) ;
                x.Add ( xx , s ) ;
            }

            File.WriteAllText ( "Resources.xaml" , XamlWriter.Save ( x ) ) ;
        }

        private void CurrentDomainOnFirstChanceException(
            object                        sender
          , FirstChanceExceptionEventArgs e
        )
        {
         //   HandleInnerExceptions(e);
        }

        private void HandleInnerExceptions(FirstChanceExceptionEventArgs e)
        {
            try
            {
                var msg = $"{e.Exception}";
                Logger.Error(msg);
                System.Diagnostics.Debug.WriteLine("Exception: " + e.Exception);
                var inner = e.Exception.InnerException;
                var seen = new HashSet<object>();
                while (inner != null
                       && !seen.Contains(inner))
                {
                    Logger.Error(inner, inner.ToString);
                    seen.Add(inner);
                    inner = inner.InnerException;
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine("Exception: " + ex);
            }
        }
#endif

        [WpfFact ]
        public void TestContainer ( )
        {
            var scope = Container.GetScope();
            // var q1= scope.Resolve<IEnumerable<ISourceCode>>();
            // foreach ( var sourceCode in q1 )
            // {
                // Logger.Trace ( "SourceCode is {sourceCode}" , sourceCode.SourceCode ) ;
            // }
            

            var fmt = scope.Resolve < IEnumerable <IHasLogInvocations> > ( ) ;
            foreach ( var q in fmt )
            {
                Logger.Info (   
                             "tre is {x}"
                           , q.LogInvocationList
                            ) ;
            }
            Assert.NotNull(fmt);

            
        }

        [WpfFact]
        public void TestFormattedCodeControl()
        {
            FormattedCode codeControl = new FormattedCode ( ) ;
            //FormattdCode1.SetValue(ComboBox.Edit.Editable)

            var sourceText = ProjLib.LibResources.Program_Parse ;
            codeControl.SourceCode = sourceText ;
            Window w = new Window ( ) ;
            w.Content = codeControl ;

            CodeAnalyseContext context = CodeAnalyseContext.Parse ( sourceText , "test1" ) ;
            var (syntaxTree , model , compilationUnitSyntax) = context ;
            Logger.Info ( "Context is {Context}" , context) ;
            codeControl.SyntaxTree = syntaxTree ;
            codeControl.Model = model ;
            codeControl.CompilationUnitSyntax = compilationUnitSyntax ;
            codeControl.Refresh ( ) ;

            // var argument1 = XamlWriter.Save ( codeControl.FlowViewerDocument );
            // File.WriteAllText ( @"c:\data\out.xaml", argument1 ) ;
            // Logger.Info ( "xaml = {xaml}" , argument1 ) ;
            // var tree = Transforms.TransformTree ( context.SyntaxTree ) ;
            // Logger.Info ( "Tree is {tree}" , tree ) ;
            w.ShowDialog ( ) ;

        }
        [WpfFact ]
        public void TestCommand ( )
        {
            // AppDomain.CurrentDomain.FirstChanceException += ( sender , args ) => {
                // HandleInnerExceptions ( args) ;

            // } ;
            
            TransformScope transform = new TransformScope(code, new FormattedCode(), new Visitor2());
            Logger.Info ( "Transform is {transform}" , transform ) ;
            var w = new Window ( ) { } ;
            Logger.Info ( Process.GetCurrentProcess ( ).Id ) ;
            var fmt = transform.FormattedCodeControl ;
            fmt.SourceCode = transform.SourceCode ;
            w.Content = fmt ;
            var mi = new MakeInfo(fmt, transform.SourceCode);                                  
            Assert.NotNull ( mi ) ;
            // var task = fmt.TaskFactory.StartNew(ProjUtils.MakeFormattedCode, mi
                                              // , CancellationToken.None, 
                                                // TaskCreationOptions.DenyChildAttach | TaskCreationOptions.LongRunning

                                               // ,
                                                // TaskScheduler.Default
                                               // ) ;
            // fmt.tasks.Add(task);
            // w.ShowDialog();
            // Task.WaitAll ( fmt.tasks.ToArray()) ;
            // TaskCompletionSource <bool> tcs = new TaskCompletionSource < bool > ();
            // w.Closed += ( sender , args ) => tcs.TrySetResult ( true ) ;
            // Logger.Info ( "{xaml}" , XamlWriter.Save ( f.Content ) ) ;
        }

        /// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged
        ///
        /// resources.</summary>
        ///
        [ Fact ]
        public void TestSerialize ( ) { }

        [ Fact ]
        public void TestRewrite ( )
        {
            var comp = Compilation ;
            var tree = TestSyntaxTree ;
            var codeAnalyseContext = new CodeAnalyseContext (
                                                             comp.GetSemanticModel ( tree )
                                                           , tree.GetCompilationUnitRoot ( )
                                                           , null
                                                           , tree.GetRoot ( )
                                                           , new CodeSource ( "Test Source" )
                                                           , TestSyntaxTree
                                                            ) ;
            var logUsagesRewriter = new LogUsagesRewriter (
                                                           TestSyntaxTree
                                                         , codeAnalyseContext.CurrentModel
                                                         , codeAnalyseContext.Document
                                                         , codeAnalyseContext.CurrentRoot
                                                         , ( node , span )
                                                               => Logger.Info ( "{span}" , span )
                                                          ) ;
            var syntaxNode = logUsagesRewriter.Visit ( tree.GetRoot ( ) ) ;
            var s = new StringWriter ( ) ;
            using ( var fileStream = File.OpenWrite ( @"out.cs" ) )
            {
                syntaxNode.WriteTo ( new StreamWriter ( fileStream ) ) ;
                s.Close ( ) ;
            }
        }


        public void Dispose ( )
        {
            // _loggingFixture?.Dispose ( ) ;
            _loggingFixture.SetOutputHelper ( null ) ;
        }

        [ WpfFact ]
        public void FormattdCode1 ( ) { }
    }
}
